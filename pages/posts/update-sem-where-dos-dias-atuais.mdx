import { withRouter } from 'next/router'
import BlogPost from '../../components/layouts/blog-post'

export const meta = {
  published: true,
  publishedAt: '2020-03-21',
  title: 'Este √© o "update sem where" dos dias atuais',
  summary: 'Infelizmente, ainda √© muito comum acontecer certos problemas com os ambientes mais importantes de um projeto (leia-se beta, prod), pois mesmo que a equipe tenha boas inten√ß√µes, de manter o fluxo de desenvolvimento mais din√¢mico e otimizado, acaba pecando em alguns detalhes que fazem bastante diferen√ßa.',
  image: '/static/site-feature.png',
  language: 'br',
}

export default withRouter(({ children, router }) => (
  <BlogPost language={meta.language} path={router.pathname} meta={meta}>
    {children}
  </BlogPost>
))

Infelizmente, ainda √© muito comum acontecer certos problemas com os ambientes mais importantes de um projeto (leia-se beta, prod), pois mesmo que a equipe tenha boas inten√ß√µes, de manter o fluxo de desenvolvimento mais din√¢mico e otimizado, acaba pecando em alguns detalhes que fazem bastante diferen√ßa.

Quem nunca ouviu aquela velha hist√≥ria do(a) estagi√°rio(a) ou da pessoa desenvolvedora menos experiente que acabou fazendo um `UPDATE` sem adicionar uma cl√°usula `WHERE`? Bom, para quem trabalha com banco de dados relacionais, isso √© bem mais comum do que a gente imagina. Nos dias de hoje, com a maioria dos projetos j√° utilizando um software de controle de vers√£o üôè, muitas vezes o famoso "**update sem where**" toma novas formas. 

<figure>
  <img src="https://images.unsplash.com/photo-1521675333836-36e707ac1d20?ixlib=rb-1.2.1&w=1000&q=85&fm=jpg&crop=entropy&cs=srgb" alt="Git Branches" />
  <figcaption>Photo via Unsplash</figcaption>
</figure>

Se voc√™ ainda n√£o utiliza um software de controle de vers√£o no seu projeto, recomendo fortemente voc√™ come√ßar por este [link aqui](https://git-scm.com/book/pt-br/v2).

H√° uma certa diverg√™ncia entre **desenvolvedores de software** em rela√ß√£o a forma de integrar as altera√ß√µes de uma branch em outra. Uma parte acredita que a melhor forma seja o [rebase, mas outros acreditam que seja o merge](https://www.atlassian.com/git/tutorials/merging-vs-rebasing). Os dois, no fim das contas, resolvem o mesmo problema. 

Independente de qual abordagem voc√™ e sua equipe utilizam - e h√° algumas que utilizam as duas ao mesmo tempo, √© importante temtar manter o ambiente o mais controlado e bem definido poss√≠vel. 

Pessoas desenvolvedoras que est√£o come√ßando a carreira, tendem a repetir os passos que os seus mentores ou programadores mais experientes fazem ao tentar resolver um problema. Ent√£o, se um(a) estagi√°rio(a) pedir ajuda para atualizar a mensagem de um commit, que j√° est√° na branch remota, provavelmente voc√™ ir√° atualizar a mensagem e fazer um [`push --force-with-lease`](https://alisonmonteiro.com.br/posts/reminder-force-with-lease). Nesse momento, √© importante que a pessoa desenvolvedora entenda exatamente o que foi feito, para que n√£o tente reescrever o hist√≥rico de uma branch importante. Pois isso, pode acarretar a atualiza√ß√£o de um ambiente cr√≠tico, ap√≥s ativar uma pipeline de deployment, por exemplo.

Utilizei um exemplo que utiliza o merge como forma de integrar as altera√ß√µes, mas o mesmo se aplica ao rebase.

Para evitar que esse tipo de problema mais s√©rio aconte√ßa, √© importante que suas branches cr√≠ticas sejam protegidas contra merges de pessoas desenvolvedoras menos experientes, ou contra merge requests que n√£o tenham recebido uma quantidade de aprova√ß√µes suficientes, por exemplo. Esse tipo de permiss√£o √© facilmente customiz√°vel na maioria das ferramentas de gerenciamento de c√≥digo GIT.

A ideia de ter branches com permiss√µes restritivas para pessoas desenvolvedoras menos experientes, √© a mesma de ter permiss√µes restritivas para os banco de dados dos ambientes mais cr√≠ticos, onde mesmo que o update sem where aconte√ßa, que seja em um ambiente controlado, assim como um `push ‚Äîforce-with-lease`.